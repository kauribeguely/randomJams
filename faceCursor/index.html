<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Live Face Rotation</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    #output {
      font-size: 20px;
      margin-top: 20px;
    }
    canvas {
      display: block;
      margin: 0 auto;
    }
    video
    {
      transform: scaleX(-1);

    }
    #codesCursor
    {
        position:absolute;
        z-index: 100;
        transition: all 0.05s ease-out;
    }
  </style>
</head>
<body>
  <h1>Live Face Rotation (Yaw and Pitch)</h1>
  <div id="output">
    <p><strong>Yaw (Y Rotation):</strong> <span id="yaw">0</span>°</p>
    <p><strong>Pitch (X Rotation):</strong> <span id="pitch">0</span>°</p>
    <p><strong>Roll (Z Rotation):</strong> <span id="roll">0</span>°</p>
    <p><strong>XandY</strong> <span id="test">0</span></p>

  </div>
  <img id='codesCursor' src='akacodescursor.png'>
  <video id="video" autoplay muted playsinline width="640" height="480"></video>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
  <script>
    const video = document.getElementById('video');
    const yawDisplay = document.getElementById('yaw');
    const pitchDisplay = document.getElementById('pitch');
    const rollDisplay = document.getElementById('roll');
    const cursor = document.getElementById('codesCursor');
    const test = document.getElementById('test');

    // Initialize an array to store positions
    const positionsArray = [];

    var screenW = window.innerWidth;
    var screenH = window.innerHeight;

    // Function to calculate yaw and pitch
    function calculateRotations(landmarks) {
      const { nose, leftEye, rightEye } = landmarks;

      // Calculate yaw (horizontal rotation) Y AXIS
      // const yaw = Math.atan2(
      //   leftEye.x - rightEye.x,
      //   leftEye.y + rightEye.y
      // );
      const yaw = Math.atan2(
        rightEye.z - leftEye.z,
        rightEye.x - leftEye.x
      );

      // Calculate pitch (vertical rotation) X AXIS
      const pitch = Math.atan2(
        nose.y - (leftEye.y + rightEye.y) / 2,
        nose.z
      );

      // Calculate roll (Z rotation)
      let roll = Math.atan2(
        leftEye.y - rightEye.y,
        leftEye.x - rightEye.x
      );


      // Convert radians to degrees and normalize
      roll = (roll * 180) / Math.PI;
      if(roll > 0) roll = 180-roll;
      if(roll < 0) roll = (180+roll)*-1;
      // roll = (roll + 360) % 360; // Normalize to 0-360
      // if (roll > 180) roll -= 360; // Convert to -180 to 180 range

      // Convert radians to degrees
      return {
        pitch: (pitch * 180) / Math.PI - 115,
        yaw: (yaw * 180) / Math.PI ,
        roll: roll
     };
    }

    // Function to update rotations on the screen
    function updateRotationDisplay(rotations) {
      yawDisplay.textContent = rotations.yaw.toFixed(2);
      pitchDisplay.textContent = rotations.pitch.toFixed(2);
      rollDisplay.textContent = rotations.roll.toFixed(2);
    }

    // Start video stream
    async function startVideo() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
    }

    startVideo();

    // Initialize Mediapipe FaceMesh
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults((results) => {
      if (results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];

        // Extract required landmarks
        const data = {
          nose: { x: landmarks[1].x, y: landmarks[1].y, z: landmarks[1].z },
          leftEye: { x: landmarks[33].x, y: landmarks[33].y, z: landmarks[33].z },
          rightEye: { x: landmarks[263].x, y: landmarks[263].y, z: landmarks[263].z }
        };

        // Calculate rotations
        const rotations = calculateRotations(data);

        // Update rotation values on screen
        updateRotationDisplay(rotations);
        updateCursorPosition(rotations);
      }
    });

    // Start Mediapipe with the video element
    const camera = new Camera(video, {
      onFrame: async () => {
        await faceMesh.send({ image: video });
      },
      width: 640,
      height: 480
    });
    camera.start();


    //todo can use these values in a calibration phase
    const yRotateRange = 20;
    const xLowest = -5;
    const xHighest = 10;

    let prevX = 0;
    let prevY = 0;

    const minDistanceToUpdate = 50;

    function updateCursorPosition(rotations)
    {
      const xRange = -rotations.yaw / yRotateRange; // -1 to 1
      const xPos = (xRange / 2 + 0.5) * screenW; // 0 to screen width
      const xDif = Math.abs(xPos - prevX);

      let smootherX = 0.1;
      if(xDif < minDistanceToUpdate)
      {
        smootherX = 0.001;
      }
      // Dynamic smoothing for X
      const xSmoothingFactor = smootherX + Math.min(xDif, 0.5) * 0.2; // Adjust based on the difference
      const smoothedX = prevX + (xPos - prevX) * xSmoothingFactor; // Smooth based on the difference

      test.textContent = `xDif: ${xDif}`;

      // Update cursor position for X
      // cursor.style.left = smoothedX + 'px';

      // Update the previous position for the next frame
      // if(xDif < minDistanceToUpdate)
      // {
        cursor.style.left = smoothedX + 'px';
      // }
      // else
      // {
      //   cursor.style.left = xPos + 'px';
      // }

      prevX = smoothedX;


      // Calculate the range for Y (normalized value based on pitch)
      const yRange = -(rotations.pitch - xHighest) / Math.abs(xHighest - xLowest); // -1 to 1
      const yPos = yRange * screenH; // 0 to screen height

      // Calculate the difference for Y
      const yDif = Math.abs(yPos - prevY);

      let smootherY = 0.1;
      if(yDif < minDistanceToUpdate)
      {
        smootherY = 0.001;
      }

      // Dynamic smoothing for Y
      const ySmoothingFactor = smootherY + Math.min(yDif, 0.5) * 0.2; // Adjust based on the difference
      const smoothedY = prevY + (yPos - prevY) * ySmoothingFactor; // Smooth the transition

      // Update cursor position for Y
      // if(yDif < minDistanceToUpdate)
      // {
        cursor.style.top = smoothedY + 'px';
      // }
      // else
      // {
      //   cursor.style.top = yPos + 'px';
      // }

      // Update the previous position for the next frame
      prevY = smoothedY;

      // }

      // console.log(`xPos: ${xRange} yPos: ${yRange}`);
      // test.textContent = `xPos: ${xRange}`;
      // test.textContent = `yPos: ${yRange}`;

      // test.textContent = `xPos: ${xRange} yPos: ${yRange}`;
    }


  </script>
</body>
</html>
